<article xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         version="5.2">
<info>
<title>Writing Invisible XML grammars</title>
<author>
<personname>
  <firstname>Norm</firstname><surname>Tovey-Walsh</surname>
</personname></author>
<copyright><year>2022</year><holder>Norm Tovey-Walsh</holder></copyright>
<abstract>
<para>This article is a draft that I intend to submit to
XML.com for publication. Please don’t share this URI at this time.
Thanks.</para>
</abstract>
</info>

<para>This article is a follow-up to the introduction to
<link xlink:href="https://www.xml.com/articles/2022/03/01/invisible-xml/">Invisible XML</link> published
at <link xlink:href="https://www.xml.com/">XML.com</link> on 1 March 2022.
In this article, we’re going to focus on the syntax of Invisible XML documents and how
to write (and debug) grammars. If you’re not already familiar with the principles
behind Invisible XML, you may want to read the introductory article first.</para>

<section xml:id="intro">
<title>Introduction</title>

<para>If you’re familiar with writing grammars in any
<link xlink:href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">BNF</link>
(or <link xlink:href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">EBNF</link>) form,
you’ll find Invisible XML easy to use. If you’ve never written a
grammar like this before, you’re in for a treat, this is fun!</para>

<para>You’ll soon discover that writing an Invisible XML grammar
shares a lot with writing an XML schema (defining a hierarchy of symbols) or a regular
expression (figuring out how to match an item and what to replace it with).
As we said last time, a <firstterm>grammar</firstterm> is a
collection of rules. Each rule has a “left hand side” and a “right
hand side”. The left hand side is a single symbol, the one being
defined, and the right hand side is a list of symbols that
define it. A <firstterm>symbol</firstterm> is either the name of
a symbol, in which case there must be a further rule that defines it,
or it’s something that
literally matches characters in your input.</para>

<para>This article describes the syntax of Invisible XML as published in the
draft specification of 22 February 2022. In the event that the community group
introduces grammar changes, we’ll try to make sure this article stays up-to-date.
</para>

<para>Invisible XML is defined by an Invisible XML grammar. It is an
instance of itself. The
<link xlink:href="https://invisiblexml.org/ixml-specification.html#complete">complete
grammar</link> is only about 45 rules. Printed, it would fit on one side
of a sheet of standard office paper.</para>

<para>Let’s dig in. We’re going to bounce around a little bit at
first, but eventually we’ll settle in to writing some longer, less
contrived grammars.</para>

<section xml:id="playalong">
<title>Play along at home!</title>

<para>As you read this article and look at the examples it contains,
we encourage you to play along at home. You’ll learn a lot from trying
out the examples! As you learn new concepts, extend the examples and
try matching your own inputs.</para>

<para>For an even more interactive introduction to Invisible XML, check out
<personname>Steven Pemberton</personname>’s
<link xlink:href="https://homepages.cwi.nl/~steven/ixml/tutorial/">Invisible XML (ixml) Tutorial</link>
presented at <link xlink:href="https://declarative.amsterdam/">Declarative Amsterdam</link>
in 2021.</para>

<para>Steven’s tutorial includes <link
xlink:href="https://homepages.cwi.nl/~steven/ixml/tutorial/run.html">an
online form</link> where you can upload a grammar and an input file to
be processed. Alternatively, you can download <link
xlink:href="https://coffeepot.nineml.org">CoffeePot</link>, a
command line Invisible XML processor that’s part of the <link
xlink:href="https://nineml.org/">NineML</link> family of Invisible XML
tools. (It’s a Java application and should run easily on Linux, MacOS, and Windows computers.)</para>
</section>

<section xml:id="howtoread">
<title>Input or output?</title>

<para>Writing grammars is about creating rules that match against
things in the input. Those rules are, in turn, used to create XML elements
and attributes that will appear in the output. These aren’t completely
independent. Annotations that you put in the grammar will influence
how the XML is created.</para>

<para>In this article, we’ve organized the two sections separately.
First, we’ll look at the input, and then we’ll talk about the output.
If you’re working through examples and starting to experiment with
grammars on your own, you may want to know something about the output
sooner rather than later. Feel free to skip back and forth. If you’ve never
written grammars of this type before, do read the first
few sections of “The input” about rules and matching first.</para>

<para>Bear in mind as you go that the goal of Invisible XML is to produce “visible XML”.
That’s not necessarily the final output form that you want. It’s “text to XML”, not
“text to DocBook 5.2 with embedded MathML and SVG.” There are other, better tools to
transform one flavor of XML into another, Invisible XML doesn’t have to do <emphasis>all</emphasis>
the lifting.</para>

</section>
</section>

<section xml:id="input">
<title>The input</title>

<para>Before we begin looking at rules, we need to think about what is being
processed by them. If you have any experience with parsing technologies, you
may be used to the idea that processing an input has two phases: a lexical
analysis phase (“the lexer”) and a parsing phase (“the parser”).</para>

<para>The lexer decides what parts of the input are the actual tokens.
It might remove insignificant whitespace, strip out comments,
normalize strings, etc. The parser then operates on those tokens.
The lexer does a lot of important work and the lexer for one kind of parsing
(Java, for example) simply won’t work for another kind (Python, for example).
</para>

<para>If Invisible XML was going to work this way, it would have to
provide two sets of rules, one for lexing and one for parsing. That
would add all kinds of complexity to the language. Instead, Invisible
XML has the simplest possible lexer: your input string becomes a
sequence of characters.</para>

<para>What you’re matching in rules are the individual characters of
the input: every single one of them. This is one of the reasons that writing an
Invisible XML grammar feels a little bit like writing a regular expression.
As we’ll see, this makes some things a little more complicated, but overall
it greatly simplifies Invisible XML.</para>

<section xml:id="rules">
<title>Rules</title>

<para>A rule has the form of a name (the left hand side) followed by a
colon, followed by <link linkend="epsilon">zero</link> or more symbols
(the right hand side) followed by a full stop to end the rule. If more
than one symbol appears on the right hand side, they must be separated
by commas:</para>

<programlisting linenumbering="unnumbered"
>symbol-name: defining, symbols, here .</programlisting>

<para>Invisible XML allows only a single rule for any given name. If
you want to express that a symbol can have two or more definitions,
separate the alternatives with semicolons. This rule says that a
“<code>thing</code>” is a “<code>this</code>”, followed by a
“<code>that</code>”:</para>

<programlisting linenumbering="unnumbered"
>thing: this, that .</programlisting>

<para>This rule says that a “<code>thing</code>” is a “<code>this</code>” <emphasis>or</emphasis>
a “<code>that</code>”:</para>

<programlisting linenumbering="unnumbered"
>thing: this; that .</programlisting>

<para>Whitespace around the punctuation is insignificant,
“<code>this;that</code>” is the same as “<code>this; that</code>” is
the same as “<code>this ; that</code>”. That’s true of all the rule
punctuation except that there must be at least one whitspace character between
consecutive rules.</para>

<note>
<para>Speaking of insigificant differences, Invisible XML allows
either of two separators between the left- and right-hand sides of a
rule: colon (“:”) or equals (“=”). Likewise, it allows either of two
separators to mark alternatives: semicolon (“;”) or vertical line
(“|”). In this article, I will consistently use “:” and “;”, but you’re
free to use “=” and “|” if you find them easier to read or remember.</para>
</note>

<para>Most grammars contain more than one rule. Rules are
separated by whitespace. It’s good practice, simply for readability,
to start each rule on its own line, but it’s not strictly required.</para>
</section>

<section xml:id="rhs">
<title>Organizing the “right hand side”</title>

<para>The Invisible XML specification introduces a few nonterminals
(remember, Invisible XML is defined in Invisible XML!) to organize how
we think about the symbols that appear on the right hand side of a
rule. It will be convenient later to talk about how these are
combined, so let’s take a moment to lay out some vocabulary.</para>

<para>At the highest level, what appears on the right hands side of a
rule is a series of alternatives. A series of alternatives 
is composed of one or more individual <emphasis>alternatives</emphasis>
separated from each other by “;” (or “|”). Each alternative
is composed of a series of <emphasis>terms</emphasis> separated by “,”. A
term is composed of <emphasis>factors</emphasis>. A factor is either
a terminal; a nonterminal; or another set of alternatives surrounded
by parentheses. In other words, like content models or regular expressions, you can
put parentheses around a set of alternatives and then use that group as
a factor, a part of another grouping.
</para>

<para>For example, in the following rule:</para>

<programlisting linenumbering="unnumbered"
>memo: recipient, (date, sender ; sender, date), content .</programlisting>

<para>The left hand side “<code role="symbol">memo</code>” is defined as
a single alternative composed of three terms: “<code role="symbol">recipient</code>”,
a grouped alternative in parentheses, and “<code role="symbol">content</code>”.
The first and
third terms contain a single factor each (and each of those
factors is a nonterminal not defined in this example). The second term is
a set of two alternatives enclosed in parenthesis; each of those
alternatives is composed of two terms (each a single nonterminal
factor) separated by commas.</para>

</section>

<section xml:id="literals">
<title>Matching literal characters</title>

<para>A grammar consists of nonterminals, the symbols you define with rules,
and terminals, symbols that match characters explicitly in your input.
There are a few options for matching characters in your input.</para>

<section xml:id="strings">
<title>Matching strings</title>

<para>You can match a literal string of text by using its quoted value.
The following rule says that the nonterminal symbol
<code role="symbol">jan</code> matches the literal string “January”.</para>

<programlisting linenumbering="unnumbered"
>jan: "January".</programlisting>

<para>This rule says that “<code role="symbol">month</code>” matches any of the
Gregorian calendar month names in English:</para>

<programlisting linenumbering="unnumbered"
>month: "January"; "February"; "March"; "April";
       "May"; "June"; "July"; "August";
       "September"; "October"; "November"; "December" .</programlisting>

<para>This might be a good time to try out a grammar. Save those three
lines in a plain text file named <filename>month.ixml</filename> and see
if you can make your first XML document with Invisible XML.</para>

<para>You can do this with <application>CoffeePot</application> at the command line like this:</para>

<programlisting linenumbering="unnumbered"
>coffeepot -g:month.ixml March</programlisting>

<para>(Depending on how you’ve installed <application>CoffeePot</application>, you may need to
use <code>java -jar</code> or some other variation to run <application>CoffeePot</application>. See
the documentation for details. You may also get some additional log messages
before the output shown below, depending on how you have things configured).</para>

<para>Which will print:</para>

<programlisting linenumbering="unnumbered"
>&lt;month>March&lt;/month></programlisting>

<para>Or you can do this using Steven’s form-based interface at
<link xlink:href="https://homepages.cwi.nl/~steven/ixml/tutorial/run.html"/>:
</para>

<mediaobject>
<imageobject>
<imagedata fileref="form.png" width="800"/>
</imageobject>
</mediaobject>

<para>Which returns:</para>

<mediaobject>
<imageobject>
<imagedata fileref="result.png" width="800"/>
</imageobject>
</mediaobject>

<para>Strings can be delimited by either single quotes (') or double
quotes ("). There’s no difference between the two forms except that
it’s easy to put double quotes inside single ones and single
quotes inside double ones. The string <code>'"hello"'</code> matches
the string <literal>"hello"</literal> with the quote marks; the string
<code>"don't"</code> matches the string <literal>don't</literal> with
the apostrophe.</para>

<para>If the string you want to match contains
<emphasis>both</emphasis> double <emphasis>and</emphasis> single quotes, you can escape one
inside the other by doubling them. The string <code>"I said ""there""."</code>
matches <literal>I said "there".</literal>. Similarly, <code>'don''t'</code>
matches <literal>don't</literal>. Note that in each case, these are
the ordinary, non-typographic quotes, "
(<link xlink:href="https://unicode-explorer.com/c/0022">U+0022</link>) and '
(<link xlink:href="https://unicode-explorer.com/c/0027">U+0027</link>). If
your string contains typographic quotes, those are just ordinary
characters as far as Invisible XML is concerned.</para>

<para>String literals in Invisible XML are not allowed to break across
lines. You cannot put a literal newline character in a string. To match
newline characters, use an
<link linkend="encoded">encoded character</link>.</para>

<para>You might be wondering what happens if your input <emphasis>doesn’t</emphasis> match.
You can try that out by, for example, trying to match the month “Marsh” in the previous
examples.</para>

<programlisting linenumbering="unnumbered"
>coffeepot -g:month.ixml Marsh</programlisting>

<para><application>CoffeePot</application> will print:</para>

<programlisting linenumbering="unnumbered"
><![CDATA[<fail xmlns:ixml="http://invisiblexml.org/NS" ixml:state="failed">
   <line>1</line>
   <column>4</column>
   <pos>3</pos>
   <unexpected>r</unexpected>
   <permitted>'c'</permitted>
   <also-predicted>'A', 'D', 'F', 'J', 'M', 'N', 'O', 'S'</also-predicted>
</fail>]]></programlisting>

<para>An Invisible XML processor always produces an XML result. In
this case, the result has been annotated with a “<code>failed</code>”
state and some attempt has been made to describe what went wrong. Like
most error messages from computers, it needs to be taken with a grain
of salt. The processor doesn’t <emphasis>know</emphasis> what’s wrong
in any meaningful sense, it just reports what state it was in when it gave up.</para>

<para>Steven’s form offers a similar report:</para>

<mediaobject>
<imageobject>
<imagedata fileref="badresult.png" width="800"/>
</imageobject>
</mediaobject>

</section>

<section xml:id="encoded">
<title>Matching individual characters</title>

<para>You can match any literal character, including newlines and
<link linkend="nonxml">other
control characters</link>, with an encoded character. An encoded character is
a number sign (#,
<link xlink:href="https://unicode-explorer.com/c/0023">U+0023</link>)
followed by hex digits. A newline is “#a” (or in capitals, “#A”, or with
leading zeros, “#000a”, if you prefer).
The encoded form can represent
<link linkend="nonxml">any Unicode character.</link></para>

<para>In the discussion of strings, we noted that you cannot put a newline
in a string. So how would you match “one” followed by “two” separated by a single
newline?</para>

<para>One way is like this:</para>

<programlisting linenumbering="unnumbered"
>onetwo: "one", #a, "two" .</programlisting>

<para>The commas that you put in to separate tokens don’t imply any delimiters
in the input.</para>
</section>

<section xml:id="sets">
<title>Character sets</title>

<para>Strings and encoded characters match against the input exactly
as they are written. Another way to match is with <emphasis>character
sets</emphasis> which can be inclusive (all these characters) or
exclusive (any characters except these).
</para>

<para>Character sets are delimited by square brackets and contain
literal strings, encoded characters, character ranges, or Unicode
character classes. If the opening square bracket is preceded by a “~”
(<link xlink:href="https://unicode-explorer.com/c/007E">U+007E</link>),
the set is exclusive, otherwise it’s inclusive.</para>

<para>The following rule:</para>

<programlisting linenumbering="unnumbered"
>digit: ["0123456789"] .</programlisting>

<para>Doesn’t match the string zero through nine, as it would if it wasn’t
surrounded in square brackets, instead it matches exactly one character, any
one of “0”, “1”, “2”, …, “9”.</para>

<para>Another way to write that would be with a range:</para>

<programlisting linenumbering="unnumbered"
>digit: ["0"-"9"] .</programlisting>

<para>A range consists of a character string containing a single character (or an
<link linkend="encoded">encoded character</link>)
followed by a hyphen-minus
(-, <link xlink:href="https://unicode-explorer.com/c/002D">U+002D</link>),
followed by another single
character string (or encoded character). Unlike ranges in most regular
expressions, the members of a character set are always quoted or
encoded, so you don’t need extra escaping. A character set that
includes left square bracket, both kinds of quote marks, and all of
the characters from “-” to “\” could be written:</para>

<programlisting linenumbering="unnumbered"
>["[", "'", '"', "-"-"\"]</programlisting>

<para>though it might be a little easier to read as</para>

<programlisting linenumbering="unnumbered"
>["[", "'", '"', #2d-"\"]</programlisting>

<para>or even</para>

<programlisting linenumbering="unnumbered"
>[#5b, "'", '"', #2d - "\"]</programlisting>

<para>Finally, a set can identify a Unicode character class. Unicode groups
similar characters together into classes identified by one- or two-letter codes.
The code “P”, for example, identifies all punctuation characters while “Pd”
identifies those punctuation characters that are dashes. You can use these
classes in character sets. To define the nonterminal “<code role="symbol">punct</code>” that matches
any single Unicode punctuation character, you can write this:</para>

<programlisting linenumbering="unnumbered"
>punct: [P] .</programlisting>

<para>You can combine these various forms in a single set:</para>

<programlisting linenumbering="unnumbered"
>hexplus: ["0123456789"; "A"-#46; #61-"f"; Nd].</programlisting>

<para>That defines “hexplus” as matching any single character zero
through nine, or any upper-case latter “A” through “F”, or any
lowercase letter “a” through “f”, or any character in the Unicode
character class “Number, Decimal Digit” (which contains more than 600
characters as many languages have their own decimal digits). The
Unicode class contains the Arabic decimal digits, so there’s a bit of
redundancy in this set, but that’s not an error.</para>

<para>As noted earlier, you can negate a class (make it an exclusion)
by placing a tilde in front of it:</para>

<programlisting linenumbering="unnumbered"
>notnumeric: ~[N].</programlisting>

<para>The “<code role="symbol">notnumeric</code>” nonterminal matches any single Unicode character
that is not in the class of number characters.
The set <code>~[]</code> matches any character that is not in the empty set, in other
words, <emphasis>any</emphasis> character.</para>

<para>(Invisible XML doesn’t let you build up more complicated
character sets by composing them: you can’t mix inclusions and
exclusions together in the same set.)</para>
</section>
</section>

<section xml:id="seq">
<title>Matching sequences</title>

<para>All the rules we’ve looked at so far match exactly one thing:
one word, one symbol, or one character. What if you want to match more
or less than one? Invisible XML gives you several options here as well
starting with “*”, “+”, and “?” which behave just as you’d expect if you’re
familiar with regular expression languages.</para>

<variablelist>
<varlistentry><term><literal>factor*</literal></term>
<listitem>
<para>A <link linkend="rhs">factor</link> followed by a “*” will match
zero or more occurrences of that factor. Given this rule,
</para>
<programlisting linenumbering="unnumbered"
>seq: 'a', '.'*, 'b'.</programlisting>
<para>An “<code>seq</code>” will match “<literal>ab</literal>”,
“<literal>a.b</literal>”, “<literal>a..b</literal>”, etc. with as many
full stops as you like between the two letters.</para>
</listitem>
</varlistentry>
<varlistentry><term><literal>factor+</literal></term>
<listitem>
<para>A factor followed by a “+” will match one or more occurrences
of that factor. Given this rule,
</para>
<programlisting linenumbering="unnumbered"
>seq: 'a', '.'+, 'b'.</programlisting>
<para>An “<code>seq</code>” will match “<literal>a.b</literal>”,
“<literal>a..b</literal>”, “<literal>a...b</literal>”, etc. with as many
full stops as you like between the two letters, but it will not
match “<literal>ab</literal>”.</para>
</listitem>
</varlistentry>
<varlistentry><term><literal>factor?</literal></term>
<listitem>
<para>A factor followed by a “?” is optional. It will match zero or one
occurrence of that factor. Given this rule:
</para>
<programlisting linenumbering="unnumbered"
>seq: 'a'? .</programlisting>
<para>An “<code>seq</code>” will match either nothing or a single
“<literal>a</literal>”. Matching empty strings (accidentally or on purpose) as
an important topic that we’ll come back to
<link linkend="epsilon">later</link>.</para>
</listitem>
</varlistentry>
<varlistentry><term><literal>factor1 * factor2</literal></term>
<listitem>
<para>Invisible XML has two special forms of repeat that are convenient
for grammar authors. If two factors are separated by a “*”, they will match
zero or more occurrences of the first factor <emphasis>separated</emphasis> by
the second factor. Given this rule:</para>
<programlisting linenumbering="unnumbered"
>seq: 'a'*',' .</programlisting>
<para>An “<code>seq</code>” will match “”, “<literal>a</literal>”,
“<literal>a,a</literal>”, “<literal>a,a,a</literal>”, etc. Matching as many
“<literal>a</literal>”s as appear (including none) provided that they are separated by precisely
one comma.</para>
<para>Note that because the separator is a factor as well, you can have more nuanced
separators. You could match a sequence of “a” characters separated by commas followed by optional
spaces like this: <code>'a'*(',', ' '*)</code>.</para>
</listitem>
</varlistentry>
<varlistentry><term><literal>factor1 + factor2</literal></term>
<listitem>
<para>If two factors are separated by a “+”, they will match
one or more occurrences of the first factor <emphasis>separated</emphasis> by
the second factor. Given this rule:</para>
<programlisting linenumbering="unnumbered"
>seq: 'a'+',' .</programlisting>
<para>An “<code>seq</code>” will match “<literal>a</literal>”, “<literal>a,a</literal>”,
“<literal>a,a,a</literal>”, etc. Matching as many
“<literal>a</literal>”s as appear provided that they are separated by precisely
one comma.</para>
</listitem>
</varlistentry>
</variablelist>

<note>
<para>Repetition can be subtle. The pattern “<code>sym* '}'</code>”
matches zero or more occurrences of “<code>sym</code>” (whatever that
is), <emphasis>separated</emphasis> by “<code>}</code>”s. If what you
<emphasis>intended</emphasis> was zero or more occurrences of
“<code>sym</code>” <emphasis>followed by</emphasis> a
“<code>}</code>”, you need to write “<code>sym*, '}'</code>”. It is
possible that the Invisible XML grammar will be changed slightly to
avoid this easy to miss error. For example, repetition with a
separator might require “**” and “++” so that it’s distinct from
repetition without a separator.</para>
</note>
</section>

<section xml:id="names-ws">
<title>Matching names and whitespace</title>

<para>At this point, you have all the building blocks necessary to
write your own grammars, but two common features deserve special
attention: matching names (contiguous sequences of characters) and
matching whitespace.</para>

<section xml:id="names">
<title>Matching names</title>
<para>Invisible XML grammars match characters in your input. There
isn’t a lexer in front of it to group characters into tokens and there
isn’t a “regular expression” matcher for grouping. If you want to
construct input “tokens”, you have to do it yourself.</para>
<para>You’ll find a pattern for this in the way that Invisible XML
defines a “<code role="symbol">name</code>”, for example the name of a
rule:</para>

<programlisting linenumbering="unnumbered"
>        name: namestart, namefollower*.
   namestart: ["_"; L].
namefollower: namestart; ["-.·‿⁀"; Nd; Mn].</programlisting>

<para>Those rules define names to begin with “_” or any letter,
followed by zero or more characters that are themselves “_” or letters,
or characters from a slightly broader repertoire:
hyphen-minus (-, <link xlink:href="https://unicode-explorer.com/c/002D">U+002D</link>),
full stop (., <link xlink:href="https://unicode-explorer.com/c/002E">U+002E</link>),
middle dot (·, <link xlink:href="https://unicode-explorer.com/c/00B7">U+00B7</link>),
undertie (‿, <link xlink:href="https://unicode-explorer.com/c/203F">U+203F</link>),
character tie (⁀, <link xlink:href="https://unicode-explorer.com/c/2040">U+2040</link>,
characters in the class Nd (decimal digit numbers),
and characters in the class Mn (nonspacing marks).</para>

<para>That’s the technique you have to employ if you want to make
sequences of characters. This example is a tiny bit complicated by the
fact that “name start” characters are different from the rest of the
name characters. If the whole sequence came from the same repertoire, you
could simply say something like: “<code>name: namecharacter+</code>”.</para>

<note>
<title>What’s in a name?</title>
<para>If you carefully compare what’s allowed as a name in Invisible XML with what’s
allowed as a name in XML, you’ll discover a couple of things. First, you will find that
the Invisible XML grammar is very, very slightly more generous than
<link xlink:href="https://www.w3.org/TR/REC-xml/">XML 1.0 (Fifth Edition)</link>.
Invisible XML allows three characters in names that XML forbids:
feminine ordinal indicator,
<link xlink:href="https://unicode-explorer.com/c/00AA">U+00AA</link>
(ª),
micro sign,
<link xlink:href="https://unicode-explorer.com/c/00B5">U+00B5</link>
(µ), and masculine ordinal indicator,
<link xlink:href="https://unicode-explorer.com/c/00BA">U+00BA</link>
(º). Second, you will find that very few XML parsers have really taken
the broader repertoire of name characters defined in the fifth edition on board. The popular
Apache Xerces parser, for example, rejects thousands of characters that should be allowed
in names.</para>
</note>

</section>

<section xml:id="whitespace">
<title>Matching whitespace</title>
<para>Whitespace in Invisible XML is defined as:</para>

<programlisting linenumbering="unnumbered"
>           s: (whitespace; comment)*.
  whitespace: [Zs]; tab; lf; cr.
         tab: #9.
          lf: #a.
          cr: #d.
     comment: -"{", (cchar; comment)*, -"}".
      -cchar: ~["{}"].</programlisting>

<para>The crucial observation here is that whitespace is a “zero or more”
symbol. That means everywhere that the Invisible XML grammar allows an
“<code role="symbol">s</code>” to appear in a
grammar, it can be a space, a tab, a line feed, etc., or two of them or
three of them, or <emphasis>none</emphasis> of them.
As we’ll see in <xref linkend="epsilon"/>, this can lead to
trouble (though it doesn’t in the Invisible XML specification grammar).</para>

<para>Comments in Invisible XML are considered whitespace. They’re
delimited by curly brackets and they’re defined so that they nest
properly. (You can comment out an arbitrary section of an Invisible
XML grammar without worrying about whether or not there are comments
in the section you’re commenting out!)</para>
</section>
</section>

<section xml:id="ambiguity">
<title>Ambiguity</title>

<para>As we saw in the <link
xlink:href="https://www.xml.com/articles/2022/03/01/invisible-xml/">previous
article</link>, grammars can be ambiguous and that’s not an error.
Nevertheless, ambiguous grammars can slow down the parser and
different implementations may give different answers, so it’s best to
avoid them if you can. Consider this somewhat contrived example:</para>

<programlisting linenumbering="unnumbered"><![CDATA[seq: (A; B), '.'*.
A: 'a', '.'+ .
B: 'b', '.'+ .
]]></programlisting>

<para>A “<code role="symbol">seq</code>” is an “<code role="symbol">A</code>” or a
“<code role="symbol">B</code>” followed optionally by full stops, an
“<code role="symbol">A</code>” is an “<literal>a</literal>” followed by one or more
full stops, a “<code role="symbol">B</code>” is an “<literal>b</literal>” followed
by one or more full stops.</para>

<para>Asked to parse “<literal>a..</literal>”, the Invisible XML processor will report ambiguity:</para>

<programlisting language="xml" linenumbering="unnumbered"><![CDATA[<seq xmlns:ixml="http://invisiblexml.org/NS"
     ixml:state="ambiguous">
   <A>a..</A>
</seq>
]]></programlisting>

<para><application>CoffeePot</application> will tell you that there were two possible parses, but
it only returns one of them by default because that’s conformant
behavior for a processor. Internally, it enumerates the parses and returns the first. You can
ask for the other parse by passing <code>--parse:2</code> on the command line
(alternatively, you can pass <code>--parse:all</code> for
all of them.) Here’s the second parse:</para>

<programlisting language="xml" linenumbering="unnumbered"><![CDATA[<seq xmlns:ixml="http://invisiblexml.org/NS"
     ixml:state="ambiguous">
   <A>a.</A>.</seq>
]]></programlisting>

<para>Ambiguity arises because there’s more than one way to parse an
input. In this case, it’s pretty easy to see that the ambiguity is
whether the second “<literal>.</literal>” is part of the
<code role="symbol">A</code> or part of the “<code role="symbol">seq</code>”. Removing that
ambiguity involves choosing one of the options and then adjusting the
grammar to make that the only possible parse. In this case, one option
is to make sure all the full stops are associated with either the
<code role="symbol">A</code> or the “<code role="symbol">B</code>”:
</para>

<programlisting linenumbering="unnumbered">seq: A; B.
A: 'a', '.'+ .
B: 'b', '.'+ .</programlisting>

<para>The other option is to make sure they’re all associated with the
<code role="symbol">seq</code>:
</para>

<programlisting linenumbering="unnumbered">seq: (A; B), '.'+.
A: 'a'.
B: 'b'.</programlisting>

<para>Neither answer is more correct than the other. Which one is “right”
depends on the output you want to get.</para>

<para>Ambiguity is a broader, and more nuanced topic, than we have space for here.
It’s possible to make distinctions between <emphasis>grammars</emphasis> that are ambiguous
and <emphasis>parses</emphasis> that are ambiguous. Try parsing <literal>a.</literal>
with the first grammar above and you’ll find that there’s only one parse. Invisible
XML reports ambiguous parses, not ambiguous grammars. It’s also possible to write a
grammar that has loops in it: <code>seq: 's', seq; seq; .</code> An “<code role="symbol">seq</code>” is an
<literal>s</literal> or an “<code role="symbol">seq</code>” or nothing. That grammar is infinitely
ambiguous because it can have an unbounded number of empty “<code role="symbol">seq</code>” matches.
</para>

<para>Asked to parse “sss” with that grammar,
<application>CoffeePot</application> will report:</para>

<programlisting linenumbering="unnumbered"><![CDATA[There is 1 parse, but the grammar is infinitely ambiguous
<seq xmlns:ixml="http://invisiblexml.org/NS" ixml:state="ambiguous">s
   <seq>s
      <seq>s
         <seq/>
      </seq>
   </seq>
</seq>]]></programlisting>

<para>(In the interests of space and time, <application>CoffeePot</application> won’t
let you enumerate infinitely many parses; it ignores loops.)</para>

<section xml:id="epsilon">
<title>Matching nothing</title>

<para>A very common place for ambiguity to arise is when a symbol can
match nothing. Anytime you use a “<code>*</code>” or “<code>?</code>”
modifier on a symbol, you’re indicating that the symbol can be absent.
Another way to think about “can be absent” is “can match the empty
string”. Consider</para>

<programlisting linenumbering="unnumbered"
>seq: 'x', 'o'*, 'x'.</programlisting>

<para>That rule will allow “<code role="symbol">seq</code>” to match
“<code>xx</code>” because <code>'o'*</code> can match zero occurrences
of “o”. That’s not necessarily ambiguous (and it’s not ambiguous in
this simple case), but consider a grammar for <link
xlink:href="https://en.wikipedia.org/wiki/North_American_Numbering_Plan">North
American phone numbers</link>.
</para>

<para>Ignoring the country code, a phone number in North America
consists of an area code, a prefix (technically a central office
code), and a number (technically a station number), canonically: <link
xlink:href="https://en.wikipedia.org/wiki/Fictitious_telephone_number">512‑555‑0100</link>
Unfortunately, you’ll also find (512) 555‑0100, common before the
prefix was largely mandatory, 512 555 0100, or even 5125550100.
Sometimes the area code will be missing altogether since it isn’t
<emphasis>always</emphasis> required. You might write a grammar for
phone numbers like this (ignoring additional constraints on the digits
in some parts of the number):</para>

<programlisting>phone-number: (areacode, sep)?, prefix, sep, number .
-sep: dash; space .
-dash: -'-'? .
-space: -' '? .
number: digits .
prefix: digits .
areacode: digits; -'(', digits, -')' .
-digits: ['0'-'9']+ .</programlisting>

<para>(The extra hyphen-minus signs in front of some of the rules and
symbols are explained in <xref linkend="output"/>.)</para>

<para>Presented with 512-555-0100, it quietly does what you expect, returning:</para>

<programlisting language="xml" linenumbering="unnumbered"><![CDATA[<phone-number>
   <areacode>512</areacode>
   <prefix>555</prefix>
   <number>0100</number>
</phone-number>]]></programlisting>

<para>Presented with 5125550100, things go a little sideways.
<application>CoffeePot</application> will tell you that there are 48 possible parses, including this one:</para>

<programlisting language="xml" linenumbering="unnumbered"><![CDATA[<phone-number xmlns:ixml="http://invisiblexml.org/NS"
              ixml:state="ambiguous">
   <areacode>51255501</areacode>
   <prefix>0</prefix>
   <number>0</number>
</phone-number>]]></programlisting>

<para>Can you see why there are 48 parses? That grammar allows
optional punctuation between every digit and it allows one or more
digits in each part. Of course, that’s not actually how North American phone numbers work. This
is a better grammar that describes the area code, prefix, and number with
explicit lengths:</para>

<programlisting>phone-number: (areacode, sep)?, prefix, sep, number .
-sep: dash; space .
-dash: -'-'? .
-space: -' '? .
number: digit, digit, digit, digit .
prefix: digit, digit, digit .
areacode: digit, digit, digit;
          -'(', digit, digit, digit, -')' .
-digit: ['0'-'9'] .</programlisting>

<para>This will correctly parse the number, but curiously it will still report ambiguity,
asserting four possible parses. Can you see why?</para>

<para>You can ask <application>CoffeePot</application> to tell you why with the <code>--describe-ambiguity</code>
option:</para>

<programlisting linenumbering="unnumbered">There are 4 possible parses.
Ambiguity:
sep, 3, 3
        dashⁿ, 3, 3
        spaceⁿ, 3, 3
sep, 6, 6
        dashⁿ, 6, 6
        spaceⁿ, 6, 6</programlisting>

<para>What this says, somewhat cryptically, is that
<code role="symbol">sep</code> matches the empty strings at positions 3 and 6 in
two different ways: either by matching an omitted dash or an omitted
space. You can fix this changing how “<code role="symbol">sep</code>” is defined:</para>

<programlisting>phone-number: (areacode, sep)?, prefix, sep, number .
-sep: (dash; space)? .
-dash: -'-' .
-space: -' ' .
number: digit, digit, digit, digit .
prefix: digit, digit, digit .
areacode: digit, digit, digit; -'(', digit, digit, digit, -')' .
-digit: ['0'-'9'] .</programlisting>

<para>Now a “<code role="symbol">sep</code>” is an optional dash or space, but
those aren’t independently optional. And the grammar is no longer
ambiguous. (It also no longer accepts optional separators between
every digit. Reader challenge: rewrite the grammar so that’s allowed
without reintroducing ambiguity.)</para>

<para>Another common pattern that can introduce ambiguity is when you
want to ignore whitespace. Consider this small grammar for a language
a little bit like Invisible XML:</para>

<programlisting>         rule: name, s?, ':', s?, symbol+s .
       symbol: name .

           -s: whitespace+.
  -whitespace: -[Zs]; tab; lf; cr.
         -tab: -#9.
          -lf: -#a.
          -cr: -#d.

        @name: namestart, namefollower*.
   -namestart: ["_"; L].
-namefollower: namestart; ["-.·‿⁀"; Nd; Mn].
</programlisting>

<para>It only accepts a single rule with a name before the colon and a
sequence of whitespace separated symbols after the colon. This grammar works perfectly well
and will parse “<literal>a: b c</literal>” just the way you’d expect. Now let’s
add <link linkend="output">optional marks</link>:</para>

<programlisting>         rule: name, s?, ':', s?, symbol+s .
       symbol: mark?, s?, name .

         mark: '^'; '@'; '-'.

           -s: whitespace+.
  -whitespace: -[Zs]; tab; lf; cr.
         -tab: -#9.
          -lf: -#a.
          -cr: -#d.

        @name: namestart, namefollower*.
   -namestart: ["_"; L].
-namefollower: namestart; ["-.·‿⁀"; Nd; Mn].
</programlisting>

<para>A symbol is now an optional mark, followed by optional whitespace. This introduces
ambiguity in the parse of <literal>a: b c</literal>.
If you look at the output of <literal>--describe-ambiguity</literal>,
you’ll find that the problem is in the expansion of “<code role="symbol">rule</code>”.
Imagine how you might expand “<code role="symbol">rule</code>”, substituting the value of
<code role="symbol">symbol</code> where it occurs in “<code role="symbol">rule</code>”:</para>

<programlisting linenumbering="unnumbered">rule ⇒ name, s?, ':', s?, mark?, s?, name …</programlisting>

<para>Can you see the source of the ambiguity? If there is no mark in the input, but there
is a space after the colon, there will be two ways to resolve that space.
After the colon, we could match the empty string with the first <literal>s?</literal>,
the empty string for <literal>mark?</literal>, and the space for the second <literal>s?</literal>.
Alternatively, we could do it the other way around: match the space before the mark and the
empty string after it.</para>

<para>One way to resolve this ambiguity is to change the definition of
symbol:</para>

<programlisting>       symbol: (mark, s?, name); name .</programlisting>

<para>This definition still allows an optional mark, but there’s no
second space unless there <emphasis>is</emphasis> a mark, in which
case there is no ambiguity about how to consume the space after the
colon in the rule.</para>

<para>Your first thought might have been to simply remove the
space after the colon:</para>

<programlisting>         rule: name, s?, ':', symbol+s .
       symbol: mark?, s?, name .</programlisting>

<para>This will parse <literal>a: b c</literal> unambiguously. It will
also parse <literal>a: b ^c</literal> and <literal>a:^b ^c</literal>.
But it will not parse <literal>a: ^b ^c</literal>. Can you work out why?
</para>

</section>
</section>

<section xml:id="nonxml">
<title>Non-XML characters</title>

<para>Even with entities and numeric character references, the
repertoire of XML characters is limited. You can’t, for example, have
<code>&amp;#x0;</code>
(<link xlink:href="https://unicode-explorer.com/c/0000">U+0000</link>)
in a well-formed XML document. Consequently, if
you attempt to output those characters from your Invisible XML
grammar, you’ll get errors. Similarly, if you create a nonterminal
with a name that includes characters not allowed in XML names, you’ll
get errors if it’s used for an element or attribute name.</para>

<para>Invisible XML is less restrictive. The following grammar accepts
a sequence of letters separated by null characters:</para>

<programlisting linenumbering="unnumbered">letters: letter+#0.
letter: ['A'-'Z'; 'a'-'z'].</programlisting>

<para>As long as you don’t attempt to <emphasis>output</emphasis> any invalid
characters, it’s not an error to use them.</para>

</section>
</section>

<section xml:id="output">
<title>The output</title>

<para>Whatever else your processor may be capable of, if it claims
to be a conformant Invisible XML processor, it must be able to produce
XML documents.</para>

<para>As a general rule, the Invisible XML processor makes an XML element
out of every nonterminal that it matches. Consider this simple grammar
for dates:</para>

<programlisting>date: day, ' '+, month, ' '+, year .
day: digit, digit? .
digit: ["0"-"9"] .
month: "January"; "February"; "March"; "April";
       "May"; "June"; "July"; "August";
       "September"; "October"; "November"; "December".
year: digit, digit, digit, digit .</programlisting>

<para>If you parse a date, “7 March 2022”, with that grammar, you’ll get:</para>

<programlisting language="xml"><![CDATA[<date>
   <day>
      <digit>7</digit>
   </day> 
   <month>March</month> 
   <year>
      <digit>2</digit>
      <digit>0</digit>
      <digit>2</digit>
      <digit>2</digit>
   </year>
</date>]]></programlisting>

<para>Pretty soon after the observation, “cool, it works!”, you’ll
probably want to see about getting rid of all those extra “digit” elements.
The Invisible XML grammar allows you to annotate rules, nonterminals,
and terminals with extra symbols, called “marks” in the specification,
to control how they’re used to construct XML.
</para>

<para>The mark on a nonterminal controls how it’s serialized. If a particular
nonterminal on the right-hand-side of a rule doesn’t have a mark, the mark
on the rule that defines that nonterminal is the default. The marks are:</para>

<variablelist>
<varlistentry><term><literal>^</literal> (the default mark)</term>
<listitem>
<para>A “^” is the default. On a nonterminal, it indicates that an
element should be created using the name of the nonterminal and what
matches the nonterminal should be inside it. On a terminal, it indicates
that the terminal should appear in the output.
</para>
</listitem>
</varlistentry>
<varlistentry><term><literal>@</literal></term>
<listitem>
<para>An “@” only applies to nonterminals. It indicates that an
attribute should be created using the name of the nonterminal and what
matches the nonterminal should appear in the attribute value.
</para>
</listitem>
</varlistentry>
<varlistentry><term><literal>-</literal></term>
<listitem>
<para>A “-” suppresses output. On a nonterminal, it suppresses the
name of the nonterminal, not its content. On a terminal, it suppresses
the text of the terminal.
</para>
</listitem>
</varlistentry>
</variablelist>

<para>Now we can go back to the grammar and suppress all those extra
digit elements. Replacing the rule for
“<code role="symbol">digit</code>” with this one:</para>

<programlisting linenumbering="unnumbered">-digit: ["0"-"9"] .</programlisting>

<para>Changes the output to:</para>

<programlisting language="xml"><![CDATA[<date>
   <day>7</day> 
   <month>March</month> 
   <year>2022</year>
</date>]]></programlisting>

<para>Using an “@” mark will make an element into an attribute.
Consider this alternative rule for year:</para>

<programlisting linenumbering="unnumbered">@year: digit, digit, digit, digit .</programlisting>

<para>With that rule, you’ll get:</para>

<programlisting language="xml"><![CDATA[<date year="2022">
   <day>7</day> 
   <month>March</month>
</date>]]></programlisting>

<note>
<title>Notes about “@” marks</title>
<para>There are three special things to note about “@” marks.
</para>
<orderedlist>
<listitem>
<para>If a nonterminal is marked with “@”, the things that it matches
become part of the attribute value. If that includes other
nonterminals that would have become elements, they get treated as if
they had been marked “-”.</para>
</listitem>
<listitem>
<para>Nonterminals marked with “@” don’t have to appear first in
your input. In the preceding example, “<code role="symbol">day</code>” and “<code role="symbol">month</code>”
come before “<code role="symbol">year</code>”,
but marking “<code role="symbol">year</code>” with “@” still works. This is in contrast to languages
like XSLT and XQuery where attributes, if you have any, must come before
the first non-attribute (and non-namespace) child.</para>
</listitem>
<listitem>
<para>Even though you can have attributes that come “after” non-attributes,
it’s still the grammar author’s responsibility to make sure you don’t
attempt to put two attributes with the same name on a single element. That’s
an error.</para>
</listitem>
</orderedlist>
</note>

<para>We’ve been “pretty printing” the XML output in this article
because it’s easier to read that way. But it has actually obscured a
detail. The spaces between day and month and month and year are being
output. That may be fine, but sometime’s it’s not. Let’s consider a
grammar for <link
xlink:href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</link>
dates.
</para>

<programlisting linenumbering="unnumbered">date: year, '-', month, '-', day .
year: digit+.
month: digit, digit.
day: digit, digit.
-digit: ["0"-"9"].</programlisting>

<para>If you parse a date, “2022-03-07”, with that grammar, you’ll get:</para>

<programlisting language="xml"><![CDATA[<date>
   <year>2022</year>-
   <month>03</month>-
   <day>07</day>
</date>]]></programlisting>

<para>Now those extra characters really stand out. Suppress them with “-”:
</para>

<programlisting linenumbering="unnumbered">date: year, -'-', month, -'-', day .</programlisting>

<para>That yields:</para>

<programlisting language="xml"><![CDATA[<date>
   <year>2022</year>
   <month>03</month>
   <day>07</day>
</date>]]></programlisting>

<para>Note that suppressing nonterminals and terminals are independent.
Try to predict what happens if you use this grammar:</para>

<programlisting linenumbering="unnumbered">date: year, dash, month, dash, day .
-dash: '-'.
year: digit+.
month: digit, digit.
day: digit, digit.
-digit: ["0"-"9"].
</programlisting>

<para>Try it out. Were you right? Can you figure out where to put
another “-” to fix the problem?</para>

<section xml:id="cant">
<title>What you can’t do</title>

<para>This is a good place to observe that there are some things
you <emphasis>can’t</emphasis> do with Invisible XML.</para>

<itemizedlist>
<listitem>
<para>You can’t reorder the input and you can’t generate output. You
can’t, for example, parse “7 March 2022” and output “March 07, 2022”.
Not only is there no way to change the order, there’s no way to
generate either the leading “0” or the “,” needed.</para>
</listitem>
<listitem>
<para>You can’t make element names that are based on content in the input.
There’s no rule that will match a month name and produce a
<tag>&lt;March&gt;</tag> element or a <tag class="attribute">March</tag>
attribute.
</para>
</listitem>
<listitem>
<para>You can’t replace the matched value with another value. There’s
no way to match “03” and produce “March”, or vice-versa.
</para>
</listitem>
<listitem>
<para>You can’t output namespace declarations or namespaced elements
or attributes.</para>
</listitem>
</itemizedlist>

<para>Some of these are potential features for a future version of
Invisible XML. But the goal of Invisible XML isn’t to transform your
non-XML input into a final output format. The goal of Invisible XML is
to transform the structure that’s only indicated with whitespace and
other informal conventions, into <emphasis>explicit</emphasis>
XML structure that you can transform with XSLT or XProc or your
tool of choice.</para>

<para>That’s its power.</para>
</section>
</section>
</article>
